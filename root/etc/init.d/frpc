#!/bin/sh /etc/rc.common
# Copyright
# Init script for frpc (Fast Reverse Proxy Client)

START=95
STOP=10
USE_PROCD=1

NAME=frpc
PROG=/usr/bin/frpc
CONFIG_UCI=frpc
RUNTIME_DIR=/var/run/$NAME
TMP_CONFIG_TOML=$RUNTIME_DIR/$NAME.toml

# Helper: read a single option with default
uci_get() {
	local __v
	__v=$(uci -q get $CONFIG_UCI.$1.$2)
	[ -n "$__v" ] && echo "$__v" || echo "$3"
}

# Build TOML configuration from UCI
# UCI layout we expect:
# config conf 'common'  (global)
# config conf 'xxx'     (proxies)
# config init 'init'    (runtime flags)

gen_config() {
	# QUIC advanced
	local quic_keepalive_period quic_max_idle_timeout quic_max_incoming_streams
	quic_keepalive_period=$(uci_get common quic_keepalive_period "")
	quic_max_idle_timeout=$(uci_get common quic_max_idle_timeout "")
	quic_max_incoming_streams=$(uci_get common quic_max_incoming_streams "")
	# TCP mux keepalive
	local tcp_mux_keepalive_interval
	tcp_mux_keepalive_interval=$(uci_get common tcp_mux_keepalive_interval "")
	# TLS advanced
	local tls_cert_file tls_key_file tls_trusted_ca_file tls_server_name tls_disable_custom_first_byte
	tls_cert_file=$(uci_get common tls_cert_file "")
	tls_key_file=$(uci_get common tls_key_file "")
	tls_trusted_ca_file=$(uci_get common tls_trusted_ca_file "")
	tls_server_name=$(uci_get common tls_server_name "")
	tls_disable_custom_first_byte=$(uci_get common tls_disable_custom_first_byte "")
	mkdir -p "$RUNTIME_DIR"
	local common_section init_section

	# We'll parse UCI directly using uci show & awk for flexibility
	# Read global
	local server_addr server_port protocol auth_method token log_level log_to log_file log_max_days user tcp_mux heartbeat_interval heartbeat_timeout http_proxy tls_enable pool_count dial_server_timeout dial_server_keepalive connect_server_local_ip udp_packet_size
	server_addr=$(uci_get common server_addr "127.0.0.1")
	server_port=$(uci_get common server_port "7000")
	protocol=$(uci_get common protocol "tcp")
	dial_server_timeout=$(uci_get common dial_server_timeout "")
	dial_server_keepalive=$(uci_get common dial_server_keepalive "")
	connect_server_local_ip=$(uci_get common connect_server_local_ip "")
	auth_method=$(uci_get common auth_method "token")
	token=$(uci_get common token "")
	# OIDC fields
	local oidc_client_id oidc_client_secret oidc_audience oidc_token_endpoint_url
	oidc_client_id=$(uci_get common oidc_client_id "")
	oidc_client_secret=$(uci_get common oidc_client_secret "")
	oidc_audience=$(uci_get common oidc_audience "")
	oidc_token_endpoint_url=$(uci_get common oidc_token_endpoint_url "")
	log_level=$(uci_get common log_level "info")
	# New preferred key (v1 schema log.to); legacy log_file kept for migration
	log_to=$(uci_get common log_to "")
	log_file=$(uci_get common log_file "")
	if [ -z "$log_to" ] && [ -n "$log_file" ]; then
		# In-memory migrate; we do not persist automatically to avoid side effects
		log_to="$log_file"
	fi
	log_max_days=$(uci_get common log_max_days "3")
	user=$(uci_get common user "")
	tcp_mux=$(uci_get common tcp_mux "1")
	heartbeat_interval=$(uci_get common heartbeat_interval "")
	heartbeat_timeout=$(uci_get common heartbeat_timeout "")
	http_proxy=$(uci_get common http_proxy "")
	tls_enable=$(uci_get common tls_enable "")
	pool_count=$(uci_get common pool_count "")
	udp_packet_size=$(uci_get common udp_packet_size "")

	# Admin interface (WebServer)
	local webserver_addr webserver_port webserver_user webserver_pwd assets_dir login_fail_exit disable_log_color webserver_cert_file webserver_key_file webserver_ca_file start_list_raw
	webserver_addr=$(uci_get common webserver_addr "")
	webserver_port=$(uci_get common webserver_port "")
	webserver_user=$(uci_get common webserver_user "")
	webserver_pwd=$(uci_get common webserver_pwd "")
	assets_dir=$(uci_get common assets_dir "")
	webserver_cert_file=$(uci_get common webserver_cert_file "")
	webserver_key_file=$(uci_get common webserver_key_file "")
	webserver_ca_file=$(uci_get common webserver_ca_file "")
	login_fail_exit=$(uci_get common login_fail_exit "")
	disable_log_color=$(uci_get common disable_log_color "")
	# Gather start_list (DynamicList). Each appears as repeated option; use uci show for flexibility.
	start_list_raw=$(uci -q show frpc.common | sed -n "s/^frpc.common.start_list='\(.*\)'/\1/p")

	# OIDC warning collection
	local _oidc_warn=""
	if [ "$auth_method" = "oidc" ]; then
		[ -z "$oidc_client_id" ] && _oidc_warn="${_oidc_warn} clientID"
		[ -z "$oidc_client_secret" ] && _oidc_warn="${_oidc_warn} clientSecret"
		[ -z "$oidc_audience" ] && _oidc_warn="${_oidc_warn} audience"
		[ -z "$oidc_token_endpoint_url" ] && _oidc_warn="${_oidc_warn} tokenEndpointURL"
	fi

	# Write TOML header
	{
		printf '# Generated at %s\n' "$(date +%Y-%m-%d_%H:%M:%S)"
		[ -n "$_oidc_warn" ] && printf '# WARNING: OIDC selected but missing:%s (auth likely to fail)\n' "$_oidc_warn"
	} > "$TMP_CONFIG_TOML.tmp"
	{
		# Track core keys for conflict detection with extra_settings
		local _core_keys="log.to log.level log.maxDays log.disableColor serverAddr serverPort transport.protocol transport.dialServerTimeout transport.dialServerKeepalive transport.connectServerLocalIP transport.tcpMuxKeepaliveInterval transport.tcpMux transport.tls.enable udpPacketSize transport.poolCount transport.heartbeatInterval transport.heartbeatTimeout auth.method auth.token auth.oidc.clientID auth.oidc.clientSecret auth.oidc.audience auth.oidc.tokenEndpointURL user transport.proxyURL loginFailExit start webServer.addr webServer.port webServer.user webServer.password webServer.assetsDir webServer.tls.certFile webServer.tls.keyFile webServer.tls.trustedCaFile"
		# Logging: emit log.to for any non-empty non-console/dev/null target
		if [ -n "$log_to" ] && [ "$log_to" != "console" ] && [ "$log_to" != "/dev/null" ]; then
			echo "log.to = \"$log_to\""
		fi
		[ "$log_level" = "" ] || echo "log.level = \"$log_level\""
		[ "$log_max_days" = "" ] || echo "log.maxDays = $log_max_days"
		[ "$disable_log_color" = "" ] || echo "log.disableColor = $( [ "$disable_log_color" = 1 ] && echo true || echo false )"

		echo "serverAddr = \"$server_addr\""
		echo "serverPort = $server_port"
		[ "$protocol" = "" ] || echo "transport.protocol = \"$protocol\""
		[ -n "$dial_server_timeout" ] && echo "transport.dialServerTimeout = $dial_server_timeout"
		[ -n "$dial_server_keepalive" ] && echo "transport.dialServerKeepalive = $dial_server_keepalive"
		[ -n "$connect_server_local_ip" ] && echo "transport.connectServerLocalIP = \"$connect_server_local_ip\""
		[ "$tcp_mux_keepalive_interval" = "" ] || echo "transport.tcpMuxKeepaliveInterval = $tcp_mux_keepalive_interval"
		echo "transport.tcpMux = $([ "$tcp_mux" = 1 ] && echo true || echo false)"
		[ "$tls_enable" = "" ] || echo "transport.tls.enable = $( [ "$tls_enable" = 1 ] && echo true || echo false )"
		[ -n "$udp_packet_size" ] && echo "udpPacketSize = $udp_packet_size"
		[ -n "$pool_count" ] && echo "transport.poolCount = $pool_count"
		# Heartbeat logic: upstream disables heartbeatInterval/Timeout (=-1) automatically when tcpMux=true.
		# If tcp_mux=1 and user left fields empty or set to defaults (30/90), omit to inherit upstream optimization.
		if [ "$tcp_mux" = 1 ]; then
			# only write if user explicitly provided non-empty AND not equal to upstream default pair
			[ -n "$heartbeat_interval" ] && [ "$heartbeat_interval" != 30 ] && echo "transport.heartbeatInterval = $heartbeat_interval"
			[ -n "$heartbeat_timeout" ] && [ "$heartbeat_timeout" != 90 ] && echo "transport.heartbeatTimeout = $heartbeat_timeout"
		else
			# tcpMux disabled: write if user provided value
			[ -n "$heartbeat_interval" ] && echo "transport.heartbeatInterval = $heartbeat_interval"
			[ -n "$heartbeat_timeout" ] && echo "transport.heartbeatTimeout = $heartbeat_timeout"
		fi

		if [ "$auth_method" = "oidc" ]; then
			# Minimal required fields: clientID, clientSecret, audience, tokenEndpointURL
			[ -n "$oidc_client_id" ] && echo "auth.method = \"oidc\""
			[ -n "$oidc_client_id" ] && echo "auth.oidc.clientID = \"$oidc_client_id\""
			[ -n "$oidc_client_secret" ] && echo "auth.oidc.clientSecret = \"$oidc_client_secret\""
			[ -n "$oidc_audience" ] && echo "auth.oidc.audience = \"$oidc_audience\""
			[ -n "$oidc_token_endpoint_url" ] && echo "auth.oidc.tokenEndpointURL = \"$oidc_token_endpoint_url\""
		else
			[ "$token" = "" ] || {
				echo "auth.method = \"token\""
				echo "auth.token = \"$token\""
			}
		fi
		[ "$user" = "" ] || echo "user = \"$user\""
		[ "$http_proxy" = "" ] || echo "transport.proxyURL = \"$http_proxy\""
		[ "$login_fail_exit" = "" ] || echo "loginFailExit = $( [ "$login_fail_exit" = 1 ] && echo true || echo false )"
		if [ -n "$start_list_raw" ]; then
			# Build TOML array start = ["p1","p2"]
			local _sarr="" _item
			for _item in $start_list_raw; do
				[ -z "$_item" ] && continue
				[ -n "$_sarr" ] && _sarr="$_sarr,"
				_sarr="$_sarr\"$_item\""
			done
			[ -n "$_sarr" ] && echo "start = [$_sarr]"
		fi
		# Admin UI (webServer) - only generate if both addr and port are configured
		if [ -n "$webserver_addr" ] && [ -n "$webserver_port" ] && [ "$webserver_port" != "0" ]; then
			echo "webServer.addr = \"$webserver_addr\""
			echo "webServer.port = $webserver_port"
			[ -n "$webserver_user" ] && echo "webServer.user = \"$webserver_user\""
			[ -n "$webserver_pwd" ] && echo "webServer.password = \"$webserver_pwd\""
			[ -n "$assets_dir" ] && echo "webServer.assetsDir = \"$assets_dir\""
			if [ -n "$webserver_cert_file" ] && [ -n "$webserver_key_file" ]; then
				echo "webServer.tls.certFile = \"$webserver_cert_file\""
				echo "webServer.tls.keyFile = \"$webserver_key_file\""
				[ -n "$webserver_ca_file" ] && echo "webServer.tls.trustedCaFile = \"$webserver_ca_file\""
			fi
		fi

		# Proxies: iterate sections named 'conf' excluding 'common'
		# Additional settings dynamic injection: legacy '_' and new 'extra_settings'
		local _added_keys _legacy_list _new_list
		_added_keys=""
		_legacy_list=$(uci -q show frpc.common | sed -n "s/^frpc.common._='\(.*\)'/\1/p")
		_new_list=$(uci -q show frpc.common | sed -n "s/^frpc.common.extra_settings='\(.*\)'/\1/p")
		for kv in $_legacy_list $_new_list; do
			[ -z "$kv" ] && continue
			case "$kv" in *=*) key="${kv%%=*}" ; value="${kv#*=}" ;; *) continue ;; esac
			if echo " $_core_keys " | grep -qw " $key " ; then
				echo "# skipped duplicate extra setting '$key' (conflicts with core output)"
				continue
			fi
			if echo "$_added_keys" | grep -qw "$key" ; then
				continue
			fi
			_added_keys="$_added_keys $key"
			echo "$key = $value"
		done
		uci -q show $CONFIG_UCI | grep "=conf" | cut -d'.' -f2 | cut -d'=' -f1 | while read -r sec; do
			[ "$sec" = "common" ] && continue
			local type name local_ip local_port remote_port use_encryption use_compression role server_name sk custom_domains subdomain locations http_user http_pwd host_header_rewrite plugin plugin_http_user plugin_http_passwd plugin_user plugin_passwd plugin_unix_path
			local bandwidth_limit bandwidth_limit_mode proxy_protocol_version lb_group lb_group_key
			local hc_type hc_path hc_timeout hc_max_failed hc_interval server_user
			type=$(uci -q get $CONFIG_UCI.$sec.type)
			name=$(uci -q get $CONFIG_UCI.$sec.name)
			[ -z "$name" ] && continue
			[ -z "$type" ] && type="tcp"
			local_ip=$(uci -q get $CONFIG_UCI.$sec.local_ip)
			local_port=$(uci -q get $CONFIG_UCI.$sec.local_port)
			remote_port=$(uci -q get $CONFIG_UCI.$sec.remote_port)
			use_encryption=$(uci -q get $CONFIG_UCI.$sec.use_encryption)
			use_compression=$(uci -q get $CONFIG_UCI.$sec.use_compression)
			role=$(uci -q get $CONFIG_UCI.$sec.role)
			server_user=$(uci -q get $CONFIG_UCI.$sec.server_user)
			server_name=$(uci -q get $CONFIG_UCI.$sec.server_name)
			sk=$(uci -q get $CONFIG_UCI.$sec.sk)
			custom_domains=$(uci -q get $CONFIG_UCI.$sec.custom_domains)
			subdomain=$(uci -q get $CONFIG_UCI.$sec.subdomain)
			locations=$(uci -q get $CONFIG_UCI.$sec.locations)
			http_user=$(uci -q get $CONFIG_UCI.$sec.http_user)
			http_pwd=$(uci -q get $CONFIG_UCI.$sec.http_pwd)
			host_header_rewrite=$(uci -q get $CONFIG_UCI.$sec.host_header_rewrite)
			plugin=$(uci -q get $CONFIG_UCI.$sec.plugin)
			plugin_http_user=$(uci -q get $CONFIG_UCI.$sec.plugin_http_user)
			plugin_http_passwd=$(uci -q get $CONFIG_UCI.$sec.plugin_http_passwd)
			plugin_user=$(uci -q get $CONFIG_UCI.$sec.plugin_user)
			plugin_passwd=$(uci -q get $CONFIG_UCI.$sec.plugin_passwd)
			plugin_unix_path=$(uci -q get $CONFIG_UCI.$sec.plugin_unix_path)
			bandwidth_limit=$(uci -q get $CONFIG_UCI.$sec.bandwidth_limit)
			bandwidth_limit_mode=$(uci -q get $CONFIG_UCI.$sec.bandwidth_limit_mode)
			proxy_protocol_version=$(uci -q get $CONFIG_UCI.$sec.proxy_protocol_version)
			lb_group=$(uci -q get $CONFIG_UCI.$sec.lb_group)
			lb_group_key=$(uci -q get $CONFIG_UCI.$sec.lb_group_key)
			hc_type=$(uci -q get $CONFIG_UCI.$sec.hc_type)
			hc_path=$(uci -q get $CONFIG_UCI.$sec.hc_path)
			hc_timeout=$(uci -q get $CONFIG_UCI.$sec.hc_timeout)
			hc_max_failed=$(uci -q get $CONFIG_UCI.$sec.hc_max_failed)
			hc_interval=$(uci -q get $CONFIG_UCI.$sec.hc_interval)
			local visitor_flag="0"; [ "$role" = "visitor" ] && visitor_flag="1"

			if [ "$visitor_flag" = "1" ]; then
				echo "[[visitors]]"
			else
				echo "[[proxies]]"
			fi
			echo "name = \"$name\""
			echo "type = \"$type\""
			[ -n "$local_ip" ] && [ "$visitor_flag" = "0" ] && echo "localIP = \"$local_ip\""
			[ -n "$local_port" ] && [ "$visitor_flag" = "0" ] && echo "localPort = $local_port"
			[ -n "$remote_port" ] && [ "$remote_port" != '#' ] && [ "$visitor_flag" = "0" ] && echo "remotePort = $remote_port"
			[ "$use_encryption" = 1 ] && echo "transport.useEncryption = true"
			[ "$use_compression" = 1 ] && echo "transport.useCompression = true"
			[ "$visitor_flag" = "1" ] && [ -n "$server_name" ] && echo "serverName = \"$server_name\""
			[ "$visitor_flag" = "1" ] && [ -n "$server_user" ] && echo "serverUser = \"$server_user\""
			[ "$visitor_flag" = "0" ] && [ -n "$role" ] && echo "role = \"$role\""
			[ "$visitor_flag" = "0" ] && [ -n "$server_name" ] && echo "serverName = \"$server_name\""
			[ -n "$sk" ] && echo "secretKey = \"$sk\""
			if [ -n "$custom_domains" ]; then
				local _cd_line=""; custom_domains=${custom_domains//,/ } ; for X in $custom_domains; do [ -n "$_cd_line" ] && _cd_line="$_cd_line, "; _cd_line="$_cd_line\"$X\""; done; [ -n "$_cd_line" ] && echo "customDomains = [$_cd_line]"; fi
			[ -n "$subdomain" ] && echo "subdomain = \"$subdomain\""
			if [ -n "$locations" ]; then
				local _loc_line=""; locations=${locations//,/ } ; for X in $locations; do [ -n "$_loc_line" ] && _loc_line="$_loc_line, "; _loc_line="$_loc_line\"$X\""; done; [ -n "$_loc_line" ] && echo "locations = [$_loc_line]"; fi
			[ -n "$http_user" ] && echo "httpUser = \"$http_user\""
			[ -n "$http_pwd" ] && echo "httpPassword = \"$http_pwd\""
			[ -n "$host_header_rewrite" ] && echo "hostHeaderRewrite = \"$host_header_rewrite\""
			[ -n "$bandwidth_limit" ] && echo "transport.bandwidthLimit = \"$bandwidth_limit\""
			[ -n "$bandwidth_limit_mode" ] && echo "transport.bandwidthLimitMode = \"$bandwidth_limit_mode\""
			[ -n "$proxy_protocol_version" ] && echo "transport.proxyProtocolVersion = \"$proxy_protocol_version\""
			[ -n "$lb_group" ] && echo "loadBalancer.group = \"$lb_group\""
			[ -n "$lb_group_key" ] && echo "loadBalancer.groupKey = \"$lb_group_key\""
			if [ -n "$hc_type$hc_path$hc_timeout$hc_max_failed$hc_interval" ]; then
				[ -n "$hc_type" ] && echo "healthCheck.type = \"$hc_type\""
				[ -n "$hc_path" ] && echo "healthCheck.path = \"$hc_path\""
				[ -n "$hc_timeout" ] && echo "healthCheck.timeoutSeconds = $hc_timeout"
				[ -n "$hc_max_failed" ] && echo "healthCheck.maxFailed = $hc_max_failed"
				[ -n "$hc_interval" ] && echo "healthCheck.intervalSeconds = $hc_interval"
			fi
			if [ -n "$plugin" ]; then
				echo "[proxies.plugin]"
				echo "type = \"$plugin\""
				[ -n "$plugin_http_user" ] && echo "httpUser = \"$plugin_http_user\""
				[ -n "$plugin_http_passwd" ] && echo "httpPassword = \"$plugin_http_passwd\""
				[ -n "$plugin_user" ] && echo "user = \"$plugin_user\""
				[ -n "$plugin_passwd" ] && echo "passwd = \"$plugin_passwd\""
				[ -n "$plugin_unix_path" ] && echo "unixPath = \"$plugin_unix_path\""
				uci -q show frpc.$sec | sed -n "s/^frpc.$sec.extra_options_plugin='\(.*\)'/\1/p" | while read -r kvp; do
					[ -z "$kvp" ] && continue; case "$kvp" in *=*) echo "$kvp" ;; esac
				done
			fi
			uci -q show frpc.$sec | sed -n "s/^frpc.$sec.extra_options='\(.*\)'/\1/p" | while read -r kv; do
				[ -z "$kv" ] && continue; case "$kv" in *=*) echo "$kv" ;; esac
			done
			echo
			done
	} > "$TMP_CONFIG_TOML"
}

start_service() {
	local enabled
	enabled=$(uci_get init enabled 0)
	[ "$enabled" = "1" ] || { echo "frpc: disabled in UCI (init.enabled != 1)"; return 0; }

	# One-time migration block
	local migrated_flag
	migrated_flag=$(uci -q get frpc.init.migration_done 2>/dev/null)
	if [ "$migrated_flag" != 1 ]; then
		# log_file -> log_to
		local old_log new_log
		old_log=$(uci -q get frpc.common.log_file 2>/dev/null)
		new_log=$(uci -q get frpc.common.log_to 2>/dev/null)
		if [ -n "$old_log" ] && [ -z "$new_log" ]; then
			uci set frpc.common.log_to="$old_log"
		fi
		# Admin legacy names (defensive)
		for f in admin_port admin_user admin_pwd assets_dir; do
			val=$(uci -q get frpc.common.$f 2>/dev/null) || true
			[ -z "$val" ] && continue
			case $f in
				admin_port) uci set frpc.common.webserver_port="$val" ;;
				admin_user) uci set frpc.common.webserver_user="$val" ;;
				admin_pwd) uci set frpc.common.webserver_pwd="$val" ;;
				assets_dir) uci set frpc.common.assets_dir="$val" ;;
			esac
		done
		uci set frpc.init.migration_done=1
		uci commit frpc
	fi

	[ -x "$PROG" ] || { echo "frpc: binary $PROG not found or not executable"; return 1; }
	gen_config || return 1

	# init section runtime parameters
	local run_user run_group stdout_flag stderr_flag respawn_flag
	run_user=$(uci_get init user "")
	run_group=$(uci_get init group "")
	stdout_flag=$(uci_get init stdout 1)
	stderr_flag=$(uci_get init stderr 1)
	respawn_flag=$(uci_get init respawn 1)

	procd_open_instance
	procd_set_param command "$PROG" -c "$TMP_CONFIG_TOML"
	[ "$respawn_flag" = "1" ] && procd_set_param respawn 300 5 5
	[ "$stdout_flag" = "1" ] && procd_set_param stdout 1
	[ "$stderr_flag" = "1" ] && procd_set_param stderr 1
	[ -n "$run_user" ] && procd_set_param user "$run_user"
	[ -n "$run_group" ] && procd_set_param group "$run_group"

	# Export env vars (DynamicList env on init section)
	uci -q show frpc.init | sed -n "s/^frpc.init.env='\(.*\)'/\1/p" | while read -r envline; do
		[ -z "$envline" ] && continue
		case "$envline" in *'='*) procd_set_param env "$envline" ;; esac
	done
	procd_close_instance
}

stop_service() {
	# procd handles kill, we just cleanup temp file
	[ -f "$TMP_CONFIG_TOML" ] && rm -f "$TMP_CONFIG_TOML"
}

reload_service() {
	stop
	start
}

# qa_example: echo a minimal illustrative example of produced TOML (debug helper, not invoked automatically)
qa_example() {
	cat <<'EOF'
# Example (illustrative) frpc.toml
serverAddr = "1.2.3.4"
serverPort = 7000
transport.protocol = "quic"
transport.tls.enable = true
auth.method = "token"
auth.token = "SECRET"
[[proxies]]
name = "web1"
type = "http"
localIP = "127.0.0.1"
localPort = 8080
customDomains = ["site.example.com"]
healthCheck.type = "http"
healthCheck.path = "/health"
healthCheck.intervalSeconds = 10
transport.bandwidthLimit = "10MB"
EOF
}
